{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "task: <Task finished name='Task-1' coro=<main() done, defined at /home/ubuntu/codes/standx_mm_bot/main.py:845> exception=ValueError('I/O operation on closed file.')>\rTraceback (most recent call last):\r  File \"/home/ubuntu/.pyenv/versions/3.10.17/lib/python3.10/asyncio/runners.py\", line 44, in run\r    return loop.run_until_complete(main)\r  File \"/home/ubuntu/.pyenv/versions/3.10.17/lib/python3.10/asyncio/base_events.py\", line 636, in run_until_complete\r    self.run_forever()\r  File \"/home/ubuntu/.pyenv/versions/3.10.17/lib/python3.10/asyncio/base_events.py\", line 603, in run_forever\r    self._run_once()\r  File \"/home/ubuntu/.pyenv/versions/3.10.17/lib/python3.10/asyncio/base_events.py\", line 1871, in _run_once\r    event_list = self._selector.select(timeout)\r  File \"/home/ubuntu/.pyenv/versions/3.10.17/lib/python3.10/selectors.py\", line 469, in select\r    fd_event_list = self._selector.poll(timeout, max_ev)\rKeyboardInterrupt\r\rDuring handling of the above exception, another exception occurred:\r\rTraceback (most recent call last):\r  File \"/home/ubuntu/codes/standx_mm_bot/main.py\", line 1212, in main\r    await asyncio.sleep(REFRESH_INTERVAL)\r  File \"/home/ubuntu/.pyenv/versions/3.10.17/lib/python3.10/asyncio/tasks.py\", line 605, in sleep\r    return await future\rasyncio.exceptions.CancelledError\r\rDuring handling of the above exception, another exception occurred:\r\rTraceback (most recent call last):\r  File \"/home/ubuntu/codes/standx_mm_bot/main.py\", line 1264, in main\r    log_message(f\"AUTO RESTART | Unexpected exit, restarting in {restart_delay}s...\")\r  File \"/home/ubuntu/codes/standx_mm_bot/main.py\", line 71, in log_message\r    _console_log_file.write(f\"[{timestamp}] {message}\\n\")\rValueError: I/O operation on closed file."
        },
        {
          "type": "text",
          "text": "\n\n[파일: /home/ubuntu/codes/standx_mm_bot/main.py]\n```\n#!/usr/bin/env python3\n\"\"\"\nStandX Market Making Bot\n========================\nSimulates bidirectional limit orders at ±bps from mark_price.\nReal-time monitoring of price and maker/taker status.\n\nUsage:\n    python main.py\n\"\"\"\n\nimport sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\")))\n\nimport asyncio\nimport time\nimport uuid\nimport logging\nfrom datetime import datetime\nfrom typing import Optional, Tuple, Dict, Any, List\nfrom types import SimpleNamespace\nfrom dataclasses import dataclass, field\n\nfrom rich.console import Console\nfrom rich.live import Live\nfrom rich.table import Table\nfrom rich.panel import Panel\nfrom rich.layout import Layout\nfrom rich.text import Text\n\nfrom exchange_factory import create_exchange, symbol_create\nfrom dotenv import load_dotenv\nfrom config import (\n    MODE, EXCHANGE, COIN, AUTO_CONFIRM,\n    SPREAD_BPS, DRIFT_THRESHOLD, USE_MID_DRIFT, MARK_MID_DIFF_LIMIT, MID_UNSTABLE_COOLDOWN,\n    MIN_WAIT_SEC, REFRESH_INTERVAL,\n    SIZE_UNIT, LEVERAGE, MAX_SIZE_BTC,\n    MAX_HISTORY, MAX_CONSECUTIVE_ERRORS,\n    AUTO_CLOSE_POSITION,\n    CLOSE_METHOD, CLOSE_AGGRESSIVE_BPS, CLOSE_WAIT_SEC,\n    CLOSE_MIN_SIZE_MARKET, CLOSE_MAX_ITERATIONS,\n    SNAPSHOT_INTERVAL, SNAPSHOT_FILE, CANCEL_AFTER_DELAY,\n    RESTART_INTERVAL, RESTART_DELAY, MAX_WS_FALLBACK,\n)\n\nload_dotenv()\n\n# ==================== Logging Setup ====================\nLOG_FILE = \"position_log.txt\"\nCONSOLE_LOG_FILE = \"console_log.txt\"\n\n# File logger setup (for position tracking)\nfile_logger = logging.getLogger(\"position\")\nfile_logger.setLevel(logging.INFO)\nfile_handler = logging.FileHandler(LOG_FILE, encoding=\"utf-8\")\nfile_handler.setFormatter(logging.Formatter(\"%(asctime)s | %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"))\nfile_logger.addHandler(file_handler)\n\n\n# Console log file (cleared on startup)\n_console_log_file = open(CONSOLE_LOG_FILE, \"w\", encoding=\"utf-8\")\n\n# Keyboard interrupt flag (for auto-restart logic)\n_keyboard_interrupted = False\n\n\ndef log_message(message: str) -> None:\n    \"\"\"Log message to console_log.txt with timestamp\"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    _console_log_file.write(f\"[{timestamp}] {message}\\n\")\n    _console_log_file.flush()\n\nSTANDX_KEY = SimpleNamespace(\n    wallet_address=os.getenv(\"WALLET_ADDRESS\"),\n    chain='bsc',\n    evm_private_key=os.getenv(\"PRIVATE_KEY\"),\n    open_browser=True,\n)\n\nconsole = Console()\n\n# ==================== Position Statistics ====================\nposition_stats = {\n    \"total_closes\": 0,       # Total number of closes\n    \"total_volume\": 0.0,     # Total closed BTC volume\n    \"total_pnl\": 0.0,        # Total realized PnL (USD)\n    \"last_close_time\": 0.0,  # Last close elapsed time (sec)\n    \"total_close_time\": 0.0, # Total close elapsed time (sec)\n}\n\n\n# ==================== Simulated Orders ====================\n\n@dataclass\nclass SimOrder:\n    \"\"\"Simulated order\"\"\"\n    id: str\n    side: str  # \"buy\" or \"sell\"\n    price: float\n    size: float\n    status: str = \"open\"  # \"open\", \"filled\", \"cancelled\"\n    placed_at: datetime = field(default_factory=datetime.now)\n    reference_price: float = 0.0  # mark_price at order placement\n    message: str = \"\"\n    \nclass SimOrderManager:\n    \"\"\"Simulation order manager\"\"\"\n\n    def __init__(self):\n        self.orders: Dict[str, SimOrder] = {}\n        self.history: List[Dict[str, Any]] = []  # Order history\n        self.total_placed = 0\n        self.total_cancelled = 0\n        self.total_rebalanced = 0\n        self.is_live = False\n\n    def _append_history(self, record: Dict[str, Any]) -> None:\n        \"\"\"Append to history (with memory limit)\"\"\"\n        self.history.append(record)\n        if len(self.history) > MAX_HISTORY:\n            self.history = self.history[-MAX_HISTORY:]\n\n    async def place_order(self, side: str, price: float, size: float, reference_price: float) -> SimOrder:\n        \"\"\"Create order (simulation)\"\"\"\n        order_id = f\"SIM-{uuid.uuid4().hex[:8].upper()}\"\n        order = SimOrder(\n            id=order_id,\n            side=side,\n            price=price,\n            size=size,\n            reference_price=reference_price,\n            message=\"success\"\n        )\n        self.orders[order_id] = order\n        self.total_placed += 1\n        self._append_history({\n            \"action\": \"PLACE\",\n            \"order_id\": order_id,\n            \"side\": side,\n            \"price\": price,\n            \"time\": datetime.now()\n        })\n        return order\n\n    async def cancel_order(self, order_id: str, reason: str = \"\") -> bool:\n        \"\"\"Cancel order (simulation)\"\"\"\n        if order_id in self.orders:\n            self.orders[order_id].status = \"cancelled\"\n            del self.orders[order_id]\n            self.total_cancelled += 1\n            self._append_history({\n                \"action\": \"CANCEL\",\n                \"order_id\": order_id,\n                \"reason\": reason,\n                \"time\": datetime.now()\n            })\n            return True\n        return False\n\n    async def cancel_all(self, reason: str = \"\") -> int:\n        \"\"\"Cancel all orders (simulation)\"\"\"\n        count = len(self.orders)\n        for order_id in list(self.orders.keys()):\n            await self.cancel_order(order_id, reason)\n        return count\n\n    def get_open_orders(self) -> List[SimOrder]:\n        \"\"\"Get list of open orders\"\"\"\n        return list(self.orders.values())\n\n    def get_buy_order(self) -> Optional[SimOrder]:\n        \"\"\"Get BUY order\"\"\"\n        for order in self.orders.values():\n            if order.side == \"buy\":\n                return order\n        return None\n\n    def get_sell_order(self) -> Optional[SimOrder]:\n        \"\"\"Get SELL order\"\"\"\n        for order in self.orders.values():\n            if order.side == \"sell\":\n                return order\n        return None\n\n    def rebalance(self) -> None:\n        \"\"\"Increment rebalance counter\"\"\"\n        self.total_rebalanced += 1\n\n\nclass LiveOrderManager:\n    \"\"\"Live order manager (LIVE mode) - Uses server data directly\"\"\"\n\n    def __init__(self, exchange, symbol: str):\n        self.exchange = exchange\n        self.symbol = symbol\n        # Only store reference_price locally (for drift calculation, server doesn't know this)\n        self.reference_prices: Dict[str, float] = {}  # side -> reference_price\n        self.history: List[Dict[str, Any]] = []\n        self.total_placed = 0\n        self.total_cancelled = 0\n        self.total_rebalanced = 0\n        self.is_live = True\n        # Cached server orders (updated on get_orders_from_server call)\n        self._cached_orders: Dict[str, Dict] = {}  # side -> server order\n\n    def _append_history(self, record: Dict[str, Any]) -> None:\n        \"\"\"Append to history (with memory limit)\"\"\"\n        self.history.append(record)\n        if len(self.history) > MAX_HISTORY:\n            self.history = self.history[-MAX_HISTORY:]\n\n    async def place_order(self, side: str, price: float, size: float, reference_price: float) -> Optional[SimOrder]:\n        \"\"\"Create live order\"\"\"\n        try:\n            cl_ord_id = f\"MM-{uuid.uuid4().hex[:8].upper()}\"\n\n            result = await self.exchange.create_order(\n                symbol=self.symbol,\n                side=side,\n                amount=size,\n                price=price,\n                order_type=\"limit\",\n                client_order_id=cl_ord_id,\n                skip_rest=True\n            )\n            if result:\n                code = result.get(\"code\", None)\n            else:\n                code = None\n            if code == 0:\n                # Store reference_price (for drift calculation)\n                self.reference_prices[side] = reference_price\n                self.total_placed += 1\n                self._append_history({\n                    \"action\": \"PLACE\",\n                    \"order_id\": cl_ord_id,\n                    \"side\": side,\n                    \"price\": price,\n                    \"time\": datetime.now()\n                })\n                message = result.get(\"message\")\n                # Return SimOrder (for compatibility)\n                return SimOrder(\n                    id=cl_ord_id,\n                    side=side,\n                    price=price,\n                    size=size,\n                    reference_price=reference_price,\n                    message=message\n                )\n            else:\n                console.print(f\"[red]Order rejected: {result}[/red]\")\n        except Exception as e:\n            console.print(f\"[red]Order failed: {e}[/red]\")\n        return None\n\n    async def cancel_all(self, reason: str = \"\") -> int:\n        \"\"\"Cancel cached orders only (no conflict with newly created orders)\"\"\"\n        try:\n            # Explicitly pass cached orders to cancel only those orders\n            orders_to_cancel = list(self._cached_orders.values())\n            if orders_to_cancel:\n                await self.exchange.cancel_orders(symbol=self.symbol, open_orders=orders_to_cancel)\n            count = len(orders_to_cancel)\n            self.total_cancelled += count\n            if count > 0:\n                self._append_history({\n                    \"action\": \"CANCEL_ALL\",\n                    \"count\": count,\n                    \"reason\": reason,\n                    \"time\": datetime.now()\n                })\n            self.reference_prices.clear()\n            self._cached_orders.clear()\n            return count\n        except Exception as e:\n            console.print(f\"[red]Cancel all failed: {e}[/red]\")\n            self.reference_prices.clear()\n            self._cached_orders.clear()\n            return 0\n\n    async def fetch_orders(self) -> None:\n        \"\"\"Fetch orders from server and update cache\"\"\"\n        try:\n            real_orders = await self.exchange.get_open_orders(self.symbol)\n            self._cached_orders.clear()\n            for ro in real_orders:\n                side = ro.get(\"side\", \"\").lower()\n                if side in (\"buy\", \"sell\"):\n                    self._cached_orders[side] = ro\n        except Exception as e:\n            console.print(f\"[yellow]Fetch orders warning: {e}[/yellow]\")\n\n    def get_buy_order(self) -> Optional[SimOrder]:\n        \"\"\"Get BUY order (from cached server data)\"\"\"\n        server_order = self._cached_orders.get(\"buy\")\n        if server_order:\n            return SimOrder(\n                id=server_order.get(\"client_order_id\", server_order.get(\"order_id\", \"\")),\n                side=\"buy\",\n                price=float(server_order.get(\"price\", 0)),\n                size=float(server_order.get(\"size\", server_order.get(\"amount\", 0))),\n                reference_price=self.reference_prices.get(\"buy\", 0)\n            )\n        return None\n\n    def get_sell_order(self) -> Optional[SimOrder]:\n        \"\"\"Get SELL order (from cached server data)\"\"\"\n        server_order = self._cached_orders.get(\"sell\")\n        if server_order:\n            return SimOrder(\n                id=server_order.get(\"client_order_id\", server_order.get(\"order_id\", \"\")),\n                side=\"sell\",\n                price=float(server_order.get(\"price\", 0)),\n                size=float(server_order.get(\"size\", server_order.get(\"amount\", 0))),\n                reference_price=self.reference_prices.get(\"sell\", 0)\n            )\n        return None\n\n    def rebalance(self) -> None:\n        \"\"\"Increment rebalance counter\"\"\"\n        self.total_rebalanced += 1\n\n# ==================== Utility Functions ====================\n\nasync def staggered_gather(*coros, delay: float = 0):\n    \"\"\"\n    Execute coroutines in parallel with slight delays between starts.\n    Prevents WS message flooding.\n    delay=0 is equivalent to regular asyncio.gather.\n\n    Args:\n        *coros: Coroutines to execute\n        delay: Interval between coroutine starts (sec), 0 to skip\n\n    Returns:\n        List of results from all coroutines\n    \"\"\"\n    tasks = []\n    for i, coro in enumerate(coros):\n        if delay > 0 and i > 0:\n            await asyncio.sleep(delay)\n        tasks.append(asyncio.create_task(coro))\n    return await asyncio.gather(*tasks)\n\n\ndef calc_order_prices(mark_price: float, spread_bps: float) -> Tuple[float, float]:\n    \"\"\"\n    Calculate order prices at ±spread_bps from mark_price\n\n    Returns:\n        (buy_price, sell_price)\n    \"\"\"\n    buy_price = mark_price * (1 - spread_bps / 10000)\n    sell_price = mark_price * (1 + spread_bps / 10000)\n    return buy_price, sell_price\n\n\ndef check_maker_taker(\n    buy_price: float,\n    sell_price: float,\n    best_bid: float,\n    best_ask: float\n) -> Tuple[bool, bool]:\n    \"\"\"\n    Determine if order is maker or taker\n\n    Returns:\n        (buy_is_maker, sell_is_maker)\n    \"\"\"\n    # buy order: maker if price < best_ask (inside the orderbook)\n    buy_is_maker = buy_price < best_ask\n    # sell order: maker if price > best_bid (inside the orderbook)\n    sell_is_maker = sell_price > best_bid\n    return buy_is_maker, sell_is_maker\n\n\ndef calc_drift_bps(current_price: float, reference_price: float) -> float:\n    \"\"\"\n    Calculate the difference between current price and reference price in bps\n    \"\"\"\n    if reference_price == 0:\n        return 0.0\n    return abs(current_price - reference_price) / reference_price * 10000\n\n\ndef calc_spread_bps(best_bid: float, best_ask: float) -> float:\n    \"\"\"\n    Calculate orderbook spread in bps\n    \"\"\"\n    if best_bid == 0:\n        return 0.0\n    mid = (best_bid + best_ask) / 2\n    return (best_ask - best_bid) / mid * 10000\n\n\ndef format_price(price: float, decimals: int = 2) -> str:\n    \"\"\"Format price with thousand separators\"\"\"\n    return f\"{price:,.{decimals}f}\"\n\n\ndef calc_order_size(\n    available_collateral: float,\n    mark_price: float,\n    leverage: float = LEVERAGE,\n    size_unit: float = SIZE_UNIT,\n    max_size: Optional[float] = MAX_SIZE_BTC\n) -> float:\n    \"\"\"\n    Calculate order size based on collateral.\n\n    Args:\n        available_collateral: Available collateral (USD)\n        mark_price: Current mark price\n        leverage: Leverage multiplier (6x -> 3x each side for bidirectional)\n        size_unit: Minimum order unit (default 0.001 BTC)\n        max_size: Manual max size limit (None for unlimited)\n\n    Returns:\n        Order size (BTC), floored to size_unit\n\n    Example:\n        $100 collateral, BTC=$100k, leverage=6\n        -> $100 * 6 / 2 / $100k = 0.003 BTC per side\n    \"\"\"\n    if mark_price <= 0 or available_collateral <= 0:\n        return 0.0\n\n    # collateral * leverage / 2 (bidirectional) / mark_price\n    # Example: $100 * 6 / 2 / $100k = 0.003 BTC per side\n    collateral_based_size = available_collateral * leverage / 2 / mark_price\n\n    # Use smaller of collateral-based or max_size if set\n    if max_size is not None and max_size > 0:\n        size = min(collateral_based_size, max_size)\n    else:\n        size = collateral_based_size\n\n    # Floor to size_unit (e.g., 0.00367 -> 0.003)\n    # Use round to handle floating-point precision\n    size = round(size / size_unit) * size_unit\n\n    return round(size, 8)  # Final precision fix\n\n\n# ==================== Strategic Position Close ====================\n\nasync def close_position_strategic(\n    exchange,\n    symbol: str,\n    position: Dict[str, Any],\n    method: str,\n    aggressive_bps: float,\n    wait_sec: float,\n    min_size_market: float,\n    max_iterations: int,\n) -> Tuple[bool, float, int, str]:\n    \"\"\"\n    Strategic position close.\n\n    Args:\n        exchange: Exchange wrapper instance\n        symbol: Trading symbol\n        position: Position info {'size', 'side'}\n        method: \"market\", \"aggressive\", \"chase\"\n        aggressive_bps: BPS for aggressive mode\n        wait_sec: Wait time (sec)\n        min_size_market: Min size for market fallback\n        max_iterations: Max retry iterations\n\n    Returns:\n        (success, elapsed_time, iterations, log_message)\n    \"\"\"\n    pos_side = position.get(\"side\", \"\").lower()\n    remaining_size = abs(float(position.get(\"size\", 0)))\n    close_side = \"sell\" if pos_side in [\"long\", \"buy\"] else \"buy\"\n\n    start_time = time.time()\n    iterations = 0\n\n    # Market close - immediate market order\n    if method == \"market\":\n        file_logger.info(f\"  → CLOSE: MARKET order {close_side.upper()} {remaining_size:.6f}\")\n        await exchange.close_position(symbol, position)\n        elapsed = time.time() - start_time\n        return (True, elapsed, 1, f\"MARKET close ({elapsed:.2f}s)\")\n\n    # Limit order close loop (aggressive or chase)\n    while remaining_size > 0:\n        iterations += 1\n\n        # Max iterations exceeded - force market close\n        if iterations > max_iterations:\n            file_logger.info(f\"  → CLOSE iter {iterations}: max iterations exceeded, MARKET fallback {remaining_size:.6f}\")\n            await exchange.create_order(\n                symbol=symbol,\n                side=close_side,\n                amount=remaining_size,\n                order_type=\"market\",\n                is_reduce_only=True,\n            )\n            elapsed = time.time() - start_time\n            return (True, elapsed, iterations, f\"{method.upper()} close - max iterations exceeded, market fallback ({elapsed:.1f}s)\")\n\n        # Remaining size too small - market close\n        if remaining_size < min_size_market:\n            file_logger.info(f\"  → CLOSE iter {iterations}: dust {remaining_size:.6f} < {min_size_market}, MARKET fallback\")\n            await exchange.create_order(\n                symbol=symbol,\n                side=close_side,\n                amount=remaining_size,\n                order_type=\"market\",\n                is_reduce_only=True,\n            )\n            elapsed = time.time() - start_time\n            return (True, elapsed, iterations, f\"{method.upper()} close - dust market fallback ({elapsed:.1f}s, {iterations} iter)\")\n\n        # Calculate limit price based on method\n        limit_price = None\n\n        if method == \"aggressive\":\n            if aggressive_bps == 0:\n                # BPS=0 means use best price for immediate fill (like market order)\n                orderbook = await exchange.get_orderbook(symbol)\n                bids = orderbook.get(\"bids\", [])\n                asks = orderbook.get(\"asks\", [])\n                if close_side == \"sell\":\n                    # LONG close: sell at best_bid -> immediate fill\n                    limit_price = bids[0][0] if bids else None\n                else:\n                    # SHORT close: buy at best_ask -> immediate fill\n                    limit_price = asks[0][0] if asks else None\n\n                # No orderbook data - fallback to mark_price (avoid market order)\n                if limit_price is None:\n                    limit_price = float(await exchange.get_mark_price(symbol))\n            else:\n                mark_price = float(await exchange.get_mark_price(symbol))\n                if close_side == \"sell\":\n                    # LONG close: sell at lower price (faster fill)\n                    limit_price = mark_price * (1 - aggressive_bps / 10000)\n                else:\n                    # SHORT close: buy at higher price (faster fill)\n                    limit_price = mark_price * (1 + aggressive_bps / 10000)\n\n        elif method == \"chase\":\n            orderbook = await exchange.get_orderbook(symbol)\n            bids = orderbook.get(\"bids\", [])\n            asks = orderbook.get(\"asks\", [])\n\n            if close_side == \"sell\":\n                # LONG close: sell at best_ask\n                limit_price = asks[0][0] if asks else None\n            else:\n                # SHORT close: buy at best_bid\n                limit_price = bids[0][0] if bids else None\n\n            # No orderbook data - market fallback\n            if limit_price is None:\n                file_logger.info(f\"  → CLOSE iter {iterations}: no orderbook, MARKET fallback {remaining_size:.6f}\")\n                await exchange.create_order(\n                    symbol=symbol,\n                    side=close_side,\n                    amount=remaining_size,\n                    order_type=\"market\",\n                    is_reduce_only=True,\n                )\n                elapsed = time.time() - start_time\n                return (True, elapsed, iterations, f\"CHASE close - no orderbook, market fallback ({elapsed:.1f}s)\")\n\n        # Create limit order\n        cl_ord_id = f\"CLOSE-{uuid.uuid4().hex[:8].upper()}\"\n        file_logger.info(f\"  → CLOSE iter {iterations}: {close_side.upper()} {remaining_size:.6f} @ {limit_price:,.2f} ({method})\")\n        console.print(f\"[dim]Close order: {close_side.upper()} {remaining_size:.6f} @ {limit_price:,.2f}[/dim]\")\n        try:\n            await exchange.create_order(\n                symbol=symbol,\n                side=close_side,\n                amount=remaining_size,\n                price=limit_price,\n                order_type=\"limit\",\n                is_reduce_only=True,\n                client_order_id=cl_ord_id,\n            )\n        except Exception as e:\n            # Order failed - retry in next iteration\n            file_logger.info(f\"  → CLOSE iter {iterations}: order failed - {e}, retrying...\")\n            console.print(f\"[yellow]Close order failed: {e}, retrying...[/yellow]\")\n            await asyncio.sleep(1.0)\n            continue\n\n        # Poll for fill confirmation (0.01s interval, up to wait_sec)\n        poll_interval = 0.01\n        poll_start = time.time()\n        filled = False\n\n        while (time.time() - poll_start) < wait_sec:\n            await asyncio.sleep(poll_interval)\n\n            # Check position\n            new_position = await exchange.get_position(symbol)\n            if new_position is None or float(new_position.get(\"size\", 0)) == 0:\n                # Fully closed\n                elapsed = time.time() - start_time\n                file_logger.info(f\"  → CLOSE iter {iterations}: filled completely\")\n                return (True, elapsed, iterations, f\"{method.upper()} close complete ({elapsed:.1f}s, {iterations} iter)\")\n\n            # Check remaining size\n            new_remaining = abs(float(new_position.get(\"size\", 0)))\n            if new_remaining < remaining_size:\n                # Partial fill occurred\n                file_logger.info(f\"  → CLOSE iter {iterations}: partial fill {remaining_size:.6f} -> {new_remaining:.6f}\")\n                console.print(f\"[dim]Partial fill: {remaining_size:.6f} -> {new_remaining:.6f}[/dim]\")\n                remaining_size = new_remaining\n                filled = True\n\n        # Timeout with unfilled - cancel and retry\n        if not filled:\n            remaining_size = abs(float((await exchange.get_position(symbol) or {}).get(\"size\", 0)))\n            if remaining_size > 0:\n                file_logger.info(f\"  → CLOSE iter {iterations}: timeout, cancelling and retry (remaining: {remaining_size:.6f})\")\n\n        # Cancel unfilled order\n        try:\n            await exchange.cancel_order(client_order_id=cl_ord_id)\n        except Exception:\n            pass  # Already filled or cancelled\n\n    elapsed = time.time() - start_time\n    return (True, elapsed, iterations, f\"{method.upper()} close complete ({elapsed:.1f}s, {iterations} iter)\")\n\n\n# ==================== Dashboard Output (Rich) ====================\n\ndef build_dashboard(\n    symbol: str,\n    mark_price: float,\n    best_bid: float,\n    best_ask: float,\n    best_bid_size: float,\n    best_ask_size: float,\n    buy_is_maker: bool,\n    sell_is_maker: bool,\n    drift_bps: float,\n    status: str,\n    countdown: float,\n    spread_bps: float,\n    order_mgr,  # SimOrderManager or LiveOrderManager\n    available_collateral: float,\n    total_collateral: float,\n    order_size: float,\n    position: Optional[Dict[str, Any]],\n    pos_stats: Dict[str, Any],\n    last_action: str = \"\",\n    mode: str = \"TEST\"\n) -> Panel:\n    \"\"\"Build dashboard as rich Panel\"\"\"\n    from rich.table import Table\n    from rich.text import Text\n\n    now = datetime.now().strftime(\"%H:%M:%S\")\n    is_live = mode == \"LIVE\"\n\n    # Get current orders\n    buy_order = order_mgr.get_buy_order()\n    sell_order = order_mgr.get_sell_order()\n\n    # Calculate order value (USD)\n    order_value = order_size * mark_price\n\n    # ========== Main Table ==========\n    table = Table.grid(padding=(0, 1))\n    table.add_column(justify=\"left\")\n    table.add_column(justify=\"left\")\n\n    # -- Header --\n    header = Text()\n    header.append(f\"Symbol: \", style=\"bold\")\n    header.append(f\"{symbol}\", style=\"bold cyan\")\n    header.append(f\"    Time: {now}    Target: ±{SPREAD_BPS}bps\")\n    table.add_row(header, \"\")\n    table.add_row(\"\", \"\")\n\n    # -- ACCOUNT Section --\n    table.add_row(Text(\"▌ ACCOUNT\", style=\"bold cyan\"), \"\")\n    table.add_row(\n        Text(f\"  Total: ${total_collateral:,.2f}  Available: ${available_collateral:,.2f}\", style=\"green\"),\n        Text(f\"  Order Size: {order_size:.4f} {COIN} (${order_value:,.2f}) x{LEVERAGE:.0f}\", style=\"bold\")\n    )\n\n    # Position display\n    if position and position.get(\"size\", 0) != 0:\n        pos_side = position.get(\"side\", \"\").upper()\n        pos_size = float(position.get(\"size\", 0))\n        pos_entry = float(position.get(\"entry_price\", 0))\n        pos_upnl = float(position.get(\"unrealized_pnl\", 0))\n        pos_color = \"green\" if pos_side == \"LONG\" else \"red\"\n        upnl_color = \"green\" if pos_upnl >= 0 else \"red\"\n        pos_text = Text(\"  Position: \")\n        pos_text.append(f\"{pos_side} \", style=pos_color)\n        pos_text.append(f\"{pos_size:.4f} @ {format_price(pos_entry)}  uPnL: \")\n        pos_text.append(f\"${pos_upnl:+,.2f}\", style=upnl_color)\n    else:\n        pos_text = Text(\"  Position: No position\", style=\"dim\")\n    table.add_row(pos_text, \"\")\n    table.add_row(\"\", \"\")\n\n    # -- MARKET DATA Section --\n    table.add_row(Text(\"▌ MARKET DATA\", style=\"bold cyan\"), \"\")\n    # Mid price (size-weighted average)\n    total_size = best_bid_size + best_ask_size\n    mid_price = (best_bid * best_bid_size + best_ask * best_ask_size) / total_size if total_size > 0 else (best_bid + best_ask) / 2\n    mid_diff_bps = (mid_price - mark_price) / mark_price * 10000 if mark_price > 0 else 0\n    mid_diff_style = \"green\" if abs(mid_diff_bps) < 3 else (\"yellow\" if abs(mid_diff_bps) < 6 else \"red\")\n\n    # Spread color\n    if spread_bps < 5:\n        spread_style = \"green\"\n    elif spread_bps < 10:\n        spread_style = \"yellow\"\n    else:\n        spread_style = \"red\"\n    drift_style = \"yellow\" if drift_bps > DRIFT_THRESHOLD else \"green\"\n\n    # Aligned output (fixed width 12 chars)\n    table.add_row(Text(f\"  Mark:   {format_price(mark_price):>12}  │  Mid:    {format_price(mid_price):>12}\"), \"\")\n    table.add_row(Text(f\"  Bid:    {format_price(best_bid):>12}  │  Ask:    {format_price(best_ask):>12}\"), \"\")\n    spread_line = Text(f\"  Spread: \")\n    spread_line.append(f\"{spread_bps:.2f} bps\".rjust(12), style=spread_style)\n    spread_line.append(f\"  │  Drift:  \")\n    spread_line.append(f\"{drift_bps:.2f}\".rjust(6), style=drift_style)\n    spread_line.append(\" / \")\n    spread_line.append(f\"{mid_diff_bps:+.2f} bps\", style=mid_diff_style)\n    table.add_row(spread_line, \"\")\n    table.add_row(\"\", \"\")\n\n    # -- SIMULATED ORDERS Section --\n    table.add_row(Text(\"▌ SIMULATED ORDERS\", style=\"bold cyan\"), \"\")\n\n    # SELL Order (displayed above)\n    sell_maker_text = Text(\"[MAKER]\", style=\"green\") if sell_is_maker else Text(\"[TAKER]\", style=\"red\")\n    if sell_order:\n        sell_drift = calc_drift_bps(mark_price, sell_order.reference_price)\n        sell_line = Text(\"  SELL: \", style=\"red\")\n        sell_line.append(\"● OPEN  \", style=\"red bold\")\n        sell_line.append(f\"{sell_order.id}  @ {format_price(sell_order.price)}  x{sell_order.size}\")\n        sell_drift_text = Text(f\"        (drift: {sell_drift:.1f}bps)  \")\n    else:\n        sell_line = Text(\"  SELL: \", style=\"red\")\n        sell_line.append(\"○ No order\", style=\"dim\")\n        sell_drift_text = Text(\"        \")\n    sell_drift_text.append_text(sell_maker_text)\n    table.add_row(sell_line, \"\")\n    table.add_row(sell_drift_text, \"\")\n\n    # BUY Order (displayed below)\n    buy_maker_text = Text(\"[MAKER]\", style=\"green\") if buy_is_maker else Text(\"[TAKER]\", style=\"red\")\n    if buy_order:\n        buy_drift = calc_drift_bps(mark_price, buy_order.reference_price)\n        buy_line = Text(\"  BUY:  \", style=\"green\")\n        buy_line.append(\"● OPEN  \", style=\"green bold\")\n        buy_line.append(f\"{buy_order.id}  @ {format_price(buy_order.price)}  x{buy_order.size}\")\n        buy_drift_text = Text(f\"        (drift: {buy_drift:.1f}bps)  \")\n    else:\n        buy_line = Text(\"  BUY:  \", style=\"green\")\n        buy_line.append(\"○ No order\", style=\"dim\")\n        buy_drift_text = Text(\"        \")\n    buy_drift_text.append_text(buy_maker_text)\n    table.add_row(buy_line, \"\")\n    table.add_row(buy_drift_text, \"\")\n    table.add_row(\"\", \"\")\n\n    # -- STATUS Section --\n    table.add_row(Text(\"▌ STATUS\", style=\"bold cyan\"), \"\")\n\n    # Status color\n    if status == \"MONITORING\":\n        status_text = Text(\"● MONITORING - Orders active\", style=\"green bold\")\n    elif status == \"PLACING\":\n        status_text = Text(\"▶ PLACING orders...\", style=\"cyan bold\")\n    elif status == \"NO_SIZE\":\n        status_text = Text(\"✗ NO SIZE - Insufficient collateral\", style=\"red bold\")\n    elif status == \"WAITING\":\n        status_text = Text(\"◌ WAITING - Would be TAKER\", style=\"yellow bold\")\n    elif status == \"MID_WAIT\":\n        status_text = Text(\"◌ MID_WAIT - Mid drift unstable\", style=\"yellow bold\")\n    elif status == \"REBALANCING\":\n        status_text = Text(\"⟳ REBALANCING - Cancelling & replacing\", style=\"yellow bold\")\n    else:\n        status_text = Text(status)\n\n    table.add_row(Text(\"  \").append_text(status_text), \"\")\n\n    if last_action:\n        table.add_row(Text(f\"  Last: {last_action}\", style=\"dim\"), \"\")\n\n    if countdown > 0 and MIN_WAIT_SEC > 0:\n        countdown_str = f\"{countdown:.1f}s\" if countdown < 10 else f\"{int(countdown)}s\"\n        table.add_row(Text(f\"  Next check in: {countdown_str}\", style=\"dim\"), \"\")\n\n    table.add_row(\"\", \"\")\n\n    # -- STATS Section --\n    pnl_style = \"green\" if pos_stats['total_pnl'] >= 0 else \"red\"\n\n    # First line: Order statistics\n    stats_line1 = Text(\n        f\"Placed: {order_mgr.total_placed}  Cancelled: {order_mgr.total_cancelled}  Rebalanced: {order_mgr.total_rebalanced}\",\n        style=\"dim\"\n    )\n    table.add_row(stats_line1, \"\")\n\n    # Second line: Close statistics\n    stats_line2 = Text(f\"Closes: {pos_stats['total_closes']} (\", style=\"dim\")\n    stats_line2.append(f\"{pos_stats['total_volume']:.4f} BTC\", style=\"dim\")\n    stats_line2.append(\", \", style=\"dim\")\n    stats_line2.append(f\"${pos_stats['total_pnl']:+.2f}\", style=pnl_style)\n    # Close time display\n    if pos_stats.get('total_close_time', 0) > 0:\n        stats_line2.append(f\", total: {pos_stats['total_close_time']:.1f}s\", style=\"dim\")\n    if pos_stats.get('last_close_time', 0) > 0:\n        stats_line2.append(f\", last: {pos_stats['last_close_time']:.1f}s\", style=\"dim\")\n    stats_line2.append(\")\", style=\"dim\")\n    table.add_row(stats_line2, \"\")\n\n    # Wrap in Panel\n    if is_live:\n        title = \"[bold red]StandX Market Making [LIVE][/bold red]\"\n        border = \"red\"\n    else:\n        title = \"[bold cyan]StandX Market Making [TEST][/bold cyan]\"\n        border = \"cyan\"\n\n    return Panel(\n        table,\n        title=title,\n        subtitle=\"[dim]Press Ctrl+C to exit[/dim]\",\n        border_style=border\n    )\n\n\n# ==================== Main Logic ====================\n\nasync def main():\n    is_live = MODE == \"LIVE\"\n    mode_str = \"[red]LIVE[/red]\" if is_live else \"[cyan]TEST[/cyan]\"\n\n    # Log startup\n    log_message(f\"Bot started | Mode: {MODE} | Coin: {COIN} | Spread: {SPREAD_BPS}bps | Drift: {DRIFT_THRESHOLD}bps\")\n\n    console.print(f\"\\n{'='*60}\")\n    console.print(f\"  StandX Market Making Bot\")\n    console.print(f\"  Mode: {mode_str}\")\n    mid_drift_str = \"+mid\" if USE_MID_DRIFT else \"\"\n    console.print(f\"  Coin: {COIN}, Spread: {SPREAD_BPS}bps, Drift: {DRIFT_THRESHOLD}bps{mid_drift_str}, MarkMidLimit: {MARK_MID_DIFF_LIMIT}bps\")\n    console.print(f\"{'='*60}\\n\")\n\n    # LIVE mode confirmation\n    if is_live:\n        console.print(\"[bold red]WARNING: LIVE MODE - Real orders will be placed![/bold red]\")\n        console.print(f\"  Max Size: {MAX_SIZE_BTC} {COIN}\")\n        console.print(f\"  Leverage: {LEVERAGE}x\")\n        if AUTO_CONFIRM:\n            console.print(\"[yellow]AUTO_CONFIRM enabled, skipping confirmation...[/yellow]\")\n        else:\n            confirm = input(\"\\nType 'YES' to confirm: \")\n            if confirm != \"YES\":\n                console.print(\"[yellow]Aborted.[/yellow]\")\n                return\n\n\n\n    # Exchange initialization\n    console.print(\"Initializing exchange...\")\n    exchange = await create_exchange(EXCHANGE, STANDX_KEY)\n    symbol = symbol_create(EXCHANGE, COIN)\n    console.print(f\"Symbol: {symbol}\")\n    try:\n        res = await exchange.update_leverage(symbol)\n        console.print(f\"Updated to max leverage! {res}\")\n    except Exception as e:\n        console.print(f\"Failed to update to max leverage.\")\n\n    # Create order manager (based on mode)\n    if is_live:\n        order_mgr = LiveOrderManager(exchange, symbol)\n        console.print(\"[red]Using LIVE order manager[/red]\")\n    else:\n        order_mgr = SimOrderManager()\n        console.print(\"[cyan]Using SIMULATED order manager[/cyan]\")\n\n    last_action = \"\"\n\n    try:\n        # Start WS subscriptions\n        console.print(\"Subscribing to price and orderbook...\")\n        if exchange.ws_client:\n            await exchange.ws_client.subscribe_price(symbol)\n            await exchange.ws_client.subscribe_orderbook(symbol)\n\n        # Wait for initial data\n        console.print(\"Waiting for initial data...\")\n        await asyncio.sleep(2)\n\n        # LIVE mode: Fetch existing orders\n        if is_live:\n            console.print(\"Fetching existing orders...\")\n            await order_mgr.fetch_orders()\n\n        # Track order existence time\n        orders_exist_since: Optional[float] = None  # When orders started existing\n        countdown = float(MIN_WAIT_SEC)\n\n        # Consecutive error tracking\n        consecutive_errors = 0\n\n        # Snapshot tracking\n        last_snapshot_time = 0.0\n\n        # Collateral related (REST API available, refresh only when needed)\n        available_collateral = 0.0\n        total_collateral = 0.0\n        need_collateral_update = True  # True only on start + after close\n\n        # Auto restart tracking\n        start_time = time.time()\n\n        # Mid unstable cooldown tracking\n        last_mid_unstable_time = 0.0\n\n        # Main loop (flicker-free update with Live context)\n        with Live(console=console, refresh_per_second=10, transient=True) as live:\n            while True:\n                try:\n                    current_time = time.time()\n\n                    # Auto restart check (time-based)\n                    if RESTART_INTERVAL > 0 and (current_time - start_time) >= RESTART_INTERVAL:\n                        log_message(f\"AUTO RESTART | Interval: {RESTART_INTERVAL}s\")\n                        console.print(f\"\\n[yellow]Restarting after {RESTART_INTERVAL}s...[/yellow]\")\n                        if is_live:\n                            await order_mgr.exchange.cancel_orders(symbol=order_mgr.symbol)\n                            await order_mgr.exchange.close()\n                            console.print(f\"[green]All orders cancelled before restart...{RESTART_DELAY}s remains.[/green]\")\n                            await asyncio.sleep(RESTART_DELAY)\n                        file_logger.info(f\"AUTO RESTART | Interval: {RESTART_INTERVAL}s\")\n                        os.execv(sys.executable, [sys.executable] + sys.argv)\n\n                    # WS fallback check (force restart if too many REST fallbacks)\n                    if MAX_WS_FALLBACK > 0:\n                        fallback_stats = exchange.get_fallback_stats()\n                        ws_total = fallback_stats.get(\"ws_client\", {}).get(\"total\", 0)\n                        order_ws_total = fallback_stats.get(\"order_ws_client\", {}).get(\"total\", 0)\n                        if ws_total >= MAX_WS_FALLBACK or order_ws_total >= MAX_WS_FALLBACK:\n                            log_message(f\"FORCE RESTART | WS fallback exceeded (ws: {ws_total}, order_ws: {order_ws_total})\")\n                            console.print(f\"\\n[red]WS fallback limit exceeded (ws: {ws_total}, order_ws: {order_ws_total})[/red]\")\n                            console.print(\"[yellow]Force restarting to restore WS connection...[/yellow]\")\n                            if is_live:\n                                await order_mgr.exchange.cancel_orders(symbol=order_mgr.symbol)\n                                await order_mgr.exchange.close()\n                                console.print(f\"[green]All orders cancelled before restart...{RESTART_DELAY}s remains.[/green]\")\n                                await asyncio.sleep(RESTART_DELAY)\n                            file_logger.info(f\"FORCE RESTART | WS fallback exceeded (ws: {ws_total}, order_ws: {order_ws_total})\")\n                            os.execv(sys.executable, [sys.executable] + sys.argv)\n\n                    # Collateral refresh (on start or after close)\n                    if need_collateral_update:\n                        need_collateral_update = False\n                        collateral = await exchange.get_collateral()\n                        available_collateral = float(collateral.get(\"available_collateral\", 0))\n                        total_collateral = float(collateral.get(\"total_collateral\", 0))\n\n                    # ========== 0. LIVE mode: Fetch orders from server ==========\n                    if is_live:\n                        await order_mgr.fetch_orders()\n\n                    # ========== 1. Fetch real-time data ==========\n                    # Get mark_price\n                    mark_price_str = await exchange.get_mark_price(symbol)\n                    mark_price = float(mark_price_str)\n\n                    # Data validation: mark_price\n                    if mark_price <= 0:\n                        await asyncio.sleep(REFRESH_INTERVAL)\n                        continue\n\n                    # Get orderbook\n                    orderbook = await exchange.get_orderbook(symbol)\n                    bids = orderbook.get(\"bids\", [])\n                    asks = orderbook.get(\"asks\", [])\n\n                    # Data validation: orderbook\n                    if not bids or not asks:\n                        await asyncio.sleep(REFRESH_INTERVAL)\n                        continue\n\n                    best_bid = bids[0][0]\n                    best_ask = asks[0][0]\n                    best_bid_size = bids[0][1] if len(bids[0]) > 1 else 0\n                    best_ask_size = asks[0][1] if len(asks[0]) > 1 else 0\n\n                    # Calculate mid price drift (size-weighted average)\n                    total_size = best_bid_size + best_ask_size\n                    mid_price = (best_bid * best_bid_size + best_ask * best_ask_size) / total_size if total_size > 0 else (best_bid + best_ask) / 2\n                    mid_diff_bps = abs((mid_price - mark_price) / mark_price * 10000) if mark_price > 0 else 0\n\n\n                    # Calculate based on total (consistent size display even with orders)\n                    order_size = calc_order_size(total_collateral, mark_price)\n\n                    # Get position\n                    position = await exchange.get_position(symbol)\n\n                    # ========== Auto Position Close ==========\n                    if AUTO_CLOSE_POSITION and position and float(position.get(\"size\", 0)) != 0:\n                        # 1. Cancel all orders\n                        await order_mgr.cancel_all(\"Position detected - auto close\")\n                        orders_exist_since = None\n\n                        # 2. Collect position info\n                        pos_side = position.get(\"side\", \"\").upper()\n                        pos_size = abs(float(position.get(\"size\", 0)))\n                        pos_entry = float(position.get(\"entry_price\", 0))\n                        pos_pnl = float(position.get(\"unrealized_pnl\", 0))\n\n                        # Log: Position detected\n                        log_message(f\"POSITION DETECTED | {pos_side} {pos_size:.6f} BTC @ {pos_entry:.2f} | uPnL: ${pos_pnl:+.2f}\")\n                        file_logger.info(f\"POSITION DETECTED | {pos_side} {pos_size:.6f} BTC @ {pos_entry:.2f} | uPnL: ${pos_pnl:+.2f}\")\n                        console.print(f\"[yellow]Auto-closing {pos_side} {pos_size:.4f} via {CLOSE_METHOD} (uPnL: ${pos_pnl:+.2f})...[/yellow]\")\n\n                        # 3. Strategic position close\n                        try:\n                            _success, elapsed_time, iterations, close_log = await close_position_strategic(\n                                exchange=exchange,\n                                symbol=symbol,\n                                position=position,\n                                method=CLOSE_METHOD,\n                                aggressive_bps=CLOSE_AGGRESSIVE_BPS,\n                                wait_sec=CLOSE_WAIT_SEC,\n                                min_size_market=CLOSE_MIN_SIZE_MARKET,\n                                max_iterations=CLOSE_MAX_ITERATIONS,\n                            )\n\n                            # Update statistics\n                            position_stats[\"total_closes\"] += 1\n                            position_stats[\"total_volume\"] += pos_size\n                            position_stats[\"total_pnl\"] += pos_pnl\n                            position_stats[\"last_close_time\"] = elapsed_time\n                            position_stats[\"total_close_time\"] += elapsed_time\n\n                            # Log: Position closed\n                            close_msg = (\n                                f\"POSITION CLOSED  | {pos_side} {pos_size:.6f} BTC | PnL: ${pos_pnl:+.2f} | \"\n                                f\"Method: {CLOSE_METHOD} | Time: {elapsed_time:.2f}s ({iterations} iter)\"\n                            )\n                            log_message(close_msg)\n                            file_logger.info(\n                                f\"{close_msg} | Total: {position_stats['total_closes']} closes, \"\n                                f\"{position_stats['total_volume']:.6f} BTC, ${position_stats['total_pnl']:+.2f}\"\n                            )\n\n                            last_action = f\"Closed {pos_side} {pos_size:.4f} via {CLOSE_METHOD} ({elapsed_time:.1f}s, ${pos_pnl:+.2f})\"\n                            console.print(f\"[green]{close_log} (PnL: ${pos_pnl:+.2f})[/green]\")\n                        except Exception as e:\n                            log_message(f\"POSITION CLOSE FAILED | {pos_side} {pos_size:.6f} BTC | Error: {e}\")\n                            file_logger.info(f\"POSITION CLOSE FAILED | {pos_side} {pos_size:.6f} BTC | uPnL: ${pos_pnl:+.2f} | Error: {e}\")\n                            console.print(f\"[red]Failed to close position: {e}[/red]\")\n\n                        # Refresh collateral in next iteration\n                        need_collateral_update = True\n\n                        await asyncio.sleep(REFRESH_INTERVAL)\n                        continue\n\n                    # Calculate order prices\n                    buy_price, sell_price = calc_order_prices(mark_price, SPREAD_BPS)\n\n                    # Maker/taker determination\n                    buy_is_maker, sell_is_maker = check_maker_taker(\n                        buy_price, sell_price, best_bid, best_ask\n                    )\n\n                    # Calculate orderbook spread\n                    ob_spread_bps = calc_spread_bps(best_bid, best_ask)\n\n                    # Check current orders\n                    buy_order = order_mgr.get_buy_order()\n                    sell_order = order_mgr.get_sell_order()\n                    has_orders = buy_order is not None or sell_order is not None\n\n                    # Calculate drift (based on order)\n                    if buy_order:\n                        drift_bps = calc_drift_bps(mark_price, buy_order.reference_price)\n                    elif sell_order:\n                        drift_bps = calc_drift_bps(mark_price, sell_order.reference_price)\n                    else:\n                        drift_bps = 0.0\n\n                    # ========== 2. Status Determination ==========\n                    # If USE_MID_DRIFT is True, combine mark drift + mid drift; otherwise mark drift only\n                    effective_drift = (drift_bps + mid_diff_bps) if USE_MID_DRIFT else drift_bps\n                    # Wait for orders if mark-mid diff is too large (only when MARK_MID_DIFF_LIMIT > 0)\n                    mid_unstable = MARK_MID_DIFF_LIMIT > 0 and mid_diff_bps > MARK_MID_DIFF_LIMIT\n\n                    # Record mid unstable time and check cooldown\n                    if mid_unstable:\n                        last_mid_unstable_time = time.time()\n                    mid_cooldown_active = (\n                        MID_UNSTABLE_COOLDOWN > 0 and\n                        last_mid_unstable_time > 0 and\n                        (time.time() - last_mid_unstable_time) < MID_UNSTABLE_COOLDOWN\n                    )\n\n                    if order_size <= 0:\n                        status = \"NO_SIZE\"\n                    elif not buy_is_maker or not sell_is_maker:\n                        status = \"WAITING\"\n                    elif (mid_unstable or mid_cooldown_active) and not has_orders:\n                        status = \"MID_WAIT\"  # Waiting for mid drift stability (or cooldown)\n                    elif has_orders:\n                        if effective_drift > DRIFT_THRESHOLD:\n                            status = \"REBALANCING\"\n                        else:\n                            status = \"MONITORING\"\n                    else:\n                        status = \"PLACING\"\n\n                    # ========== 3. Track Order Existence Time ==========\n                    if has_orders:\n                        now = time.time()\n                        if orders_exist_since is None:\n                            orders_exist_since = now  # Orders first detected\n                        time_with_orders = now - orders_exist_since\n                        countdown = max(0.0, MIN_WAIT_SEC - time_with_orders)\n                        can_modify_orders = time_with_orders >= MIN_WAIT_SEC\n                    else:\n                        orders_exist_since = None  # Reset if no orders\n                        countdown = 0.0\n                        can_modify_orders = True  # Can place new orders immediately if none exist\n\n                    # ========== 4. Order Logic ==========\n                    # Drift check - rebalance (after MIN_WAIT_SEC delay)\n                    if has_orders and effective_drift > DRIFT_THRESHOLD and can_modify_orders:\n                        order_mgr.rebalance()\n                        await order_mgr.cancel_all(\"Drift exceeded threshold\")\n                        drift_info = f\"{drift_bps:.1f}+{mid_diff_bps:.1f}\" if USE_MID_DRIFT else f\"{drift_bps:.1f}\"\n                        last_action = f\"Cancelled for rebalance (drift: {drift_info}bps)\"\n                        orders_exist_since = None\n                        await asyncio.sleep(CANCEL_AFTER_DELAY)\n                        continue  # Place new order with fresh price in next iteration\n\n                    # No orders and maker conditions met - place new orders (only when mid stable + cooldown done)\n                    elif not has_orders and buy_is_maker and sell_is_maker and not mid_unstable and not mid_cooldown_active:\n                        buy_order, sell_order = await staggered_gather(\n                            order_mgr.place_order(\"buy\", buy_price, order_size, mark_price),\n                            order_mgr.place_order(\"sell\", sell_price, order_size, mark_price),\n                        )\n                        if buy_order and sell_order:\n                            # {'code': 0, 'message': 'success', 'request_id': '....'}\n                            has_orders = buy_order.message == 'success' and sell_order.message == 'success'\n                            last_action = f\"Placed BUY @ {format_price(buy_price)}, SELL @ {format_price(sell_price)}\"\n                            orders_exist_since = time.time()  # Start timer\n\n                    # ========== 5. Display Dashboard ==========\n                    dashboard = build_dashboard(\n                        symbol=symbol,\n                        mark_price=mark_price,\n                        best_bid=best_bid,\n                        best_ask=best_ask,\n                        best_bid_size=best_bid_size,\n                        best_ask_size=best_ask_size,\n                        buy_is_maker=buy_is_maker,\n                        sell_is_maker=sell_is_maker,\n                        drift_bps=drift_bps,\n                        status=status,\n                        countdown=countdown,\n                        spread_bps=ob_spread_bps,\n                        order_mgr=order_mgr,\n                        available_collateral=available_collateral,\n                        total_collateral=total_collateral,\n                        order_size=order_size,\n                        position=position,\n                        pos_stats=position_stats,\n                        last_action=last_action,\n                        mode=MODE\n                    )\n                    live.update(dashboard)\n\n                    # ========== 6. Save Snapshot ==========\n                    if SNAPSHOT_INTERVAL > 0 and (current_time - last_snapshot_time) >= SNAPSHOT_INTERVAL:\n                        try:\n                            buy_order = order_mgr.get_buy_order()\n                            sell_order = order_mgr.get_sell_order()\n                            with open(SNAPSHOT_FILE, \"w\", encoding=\"utf-8\") as f:\n                                f.write(f\"[{MODE}] {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n                                f.write(f\"Mark: {mark_price:,.2f} | Spread: {ob_spread_bps:.1f}bps\\n\")\n                                f.write(f\"Total: ${total_collateral:,.2f} | Available: ${available_collateral:,.2f} | Size: {order_size:.4f} BTC\\n\")\n                                if buy_order:\n                                    f.write(f\"BUY:  {buy_order.price:,.2f} ({buy_order.status})\\n\")\n                                if sell_order:\n                                    f.write(f\"SELL: {sell_order.price:,.2f} ({sell_order.status})\\n\")\n                                if position and float(position.get(\"size\", 0)) != 0:\n                                    f.write(f\"Position: {position.get('side')} {position.get('size')} uPnL: ${position.get('unrealized_pnl', 0):+.2f}\\n\")\n                                f.write(f\"Status: {status}\\n\")\n                            last_snapshot_time = current_time\n                        except Exception:\n                            pass  # Ignore snapshot failures\n\n                    # Reset error counter on success\n                    consecutive_errors = 0\n                    await asyncio.sleep(REFRESH_INTERVAL)\n\n                except Exception as e:\n                    consecutive_errors += 1\n                    backoff = min(consecutive_errors * 0.5, 10.0)  # Max 10 seconds\n                    log_message(f\"ERROR [{consecutive_errors}/{MAX_CONSECUTIVE_ERRORS}] {e}\")\n                    console.print(f\"[red][Error {consecutive_errors}/{MAX_CONSECUTIVE_ERRORS}] {e}[/red]\")\n\n                    if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:\n                        log_message(\"Too many consecutive errors, exiting...\")\n                        console.print(\"[red]Too many consecutive errors, exiting...[/red]\")\n                        break\n\n                    await asyncio.sleep(backoff)\n\n    except KeyboardInterrupt:\n        global _keyboard_interrupted\n        _keyboard_interrupted = True\n        console.print(\"\\n[yellow]Shutting down (keyboard interrupt)...[/yellow]\")\n    finally:\n        # Cancel all orders before exit (all symbol orders regardless of cache)\n        if is_live:\n            console.print(\"Cancelling all orders...\")\n            try:\n                await order_mgr.exchange.cancel_orders(symbol=order_mgr.symbol)\n                console.print(\"[green]All orders cancelled.[/green]\")\n            except Exception as e:\n                console.print(f\"[red]Failed to cancel orders: {e}[/red]\")\n\n        console.print(\"\\n[bold]Final Statistics:[/bold]\")\n        console.print(f\"  Total Orders Placed:    {order_mgr.total_placed}\")\n        console.print(f\"  Total Orders Cancelled: {order_mgr.total_cancelled}\")\n        console.print(f\"  Total Rebalances:       {order_mgr.total_rebalanced}\")\n        console.print(f\"  Position Closes:        {position_stats['total_closes']}\")\n        console.print(f\"  Total Volume Closed:    {position_stats['total_volume']:.6f} BTC\")\n        pnl_color = \"green\" if position_stats['total_pnl'] >= 0 else \"red\"\n        console.print(f\"  Total Realized PnL:     [{pnl_color}]${position_stats['total_pnl']:+.2f}[/{pnl_color}]\")\n        if position_stats['total_close_time'] > 0:\n            avg_close_time = position_stats['total_close_time'] / max(1, position_stats['total_closes'])\n            console.print(f\"  Total Close Time:       {position_stats['total_close_time']:.1f}s (avg: {avg_close_time:.1f}s)\")\n\n        console.print(\"Closing exchange connection...\")\n        await exchange.close()\n        console.print(\"Done.\")\n        log_message(\"Bot stopped\")\n\n        # Close console log file\n        _console_log_file.close()\n\n        # Auto-restart if not keyboard interrupted (server error recovery)\n        if not _keyboard_interrupted:\n            restart_delay = RESTART_DELAY if RESTART_DELAY > 0 else 5.0\n            log_message(f\"AUTO RESTART | Unexpected exit, restarting in {restart_delay}s...\")\n            console.print(f\"\\n[yellow]Unexpected exit detected. Auto-restarting in {restart_delay}s...[/yellow]\")\n            console.print(\"[dim]Press Ctrl+C again to cancel restart[/dim]\")\n            try:\n                time.sleep(restart_delay)\n                os.execv(sys.executable, [sys.executable] + sys.argv)\n            except KeyboardInterrupt:\n                console.print(\"\\n[yellow]Restart cancelled by user.[/yellow]\")\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        _keyboard_interrupted = True\n    finally:\n        # Ensure log file is closed on exit\n        if not _console_log_file.closed:\n            _console_log_file.close()\n\n```"
        }
      ]
    },
    {
      "role": "assistant",
      "content": "수정이 완료되었습니다.\n\n## 변경 사항 요약\n\n```python\ndef log_message(message: str) -> None:\n    \"\"\"Log message to console_log.txt with timestamp\"\"\"\n    # 파일이 닫혔는지 확인 후 쓰기 시도  ← 추가\n    if _console_log_file.closed:\n        return\n    try:\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        _console_log_file.write(f\"[{timestamp}] {message}\\n\")\n        _console_log_file.flush()\n    except ValueError:\n        # I/O operation on closed file 에러 무시  ← 추가\n        pass\n```\n\n## 수정 내용\n\n1. **`_console_log_file.closed` 체크**: 파일이 이미 닫혔으면 즉시 리턴\n2. **`try-except` 추가**: 혹시 체크와 쓰기 사이에 race condition이 발생하더라도 `ValueError`를 안전하게 무시\n\n이제 `finally` 블록에서 파일을 닫은 후에도 `log_message()`가 호출되더라도 에러가 발생하지 않습니다."
    }
  ],
  "model": "anthropic/claude-opus-4.5",
  "context_length": 200000,
  "usage_history": [
    {
      "completion_tokens": 353,
      "prompt_tokens": 23140,
      "total_tokens": 23493,
      "completion_tokens_details": {
        "accepted_prediction_tokens": null,
        "audio_tokens": null,
        "reasoning_tokens": 0,
        "rejected_prediction_tokens": null
      },
      "prompt_tokens_details": {
        "audio_tokens": null,
        "cached_tokens": 0,
        "cache_write_tokens": 0
      },
      "cost": 0.124525,
      "is_byok": false,
      "cost_details": {
        "upstream_inference_cost": 0.124525,
        "upstream_inference_prompt_cost": 0.1157,
        "upstream_inference_completions_cost": 0.008825
      }
    }
  ],
  "mode": "dev",
  "summary_history": [],
  "total_usage": {
    "total_prompt_tokens": 23140,
    "total_completion_tokens": 353,
    "total_tokens": 23493
  },
  "last_updated": "2026-01-22 05:48:57"
}